package plugins

import (
	"context"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"github.com/25smoking/Argus/internal/core"
	"github.com/25smoking/Argus/internal/embedded"
	"github.com/25smoking/Argus/internal/pkg/yara_lite"
)

type MalwareScanPlugin struct {
	scanner *yara_lite.Scanner
}

func (p *MalwareScanPlugin) Name() string {
	return "MalwareScan"
}

func (p *MalwareScanPlugin) Run(ctx context.Context, config *core.ScanConfig) ([]core.Result, error) {
	var results []core.Result
	var resultsMutex sync.Mutex

	// 1. åŠ è½½æ¶æ„è½¯ä»¶æ£€æµ‹è§„åˆ™ï¼ˆé Webshell è§„åˆ™ï¼‰
	ruleDir := "assets/malware_rules"
	var scanner *yara_lite.Scanner
	var err error

	// ä¼˜å…ˆå°è¯•å¤–éƒ¨è§„åˆ™
	if _, statErr := os.Stat(ruleDir); statErr == nil {
		scanner, err = yara_lite.NewScanner(os.DirFS("."), ruleDir)
	} else {
		// å›é€€åˆ°å†…åµŒè§„åˆ™
		scanner, err = yara_lite.NewScanner(embedded.Content, ruleDir)
	}

	if err != nil {
		fmt.Printf("Warning: Failed to load malware YARA rules from %s: %v. Skipping malware scan.\n", ruleDir, err)
		return nil, nil
	}
	fmt.Printf("å·²åŠ è½½ %d æ¡æ¶æ„è½¯ä»¶æ£€æµ‹è§„åˆ™\n", len(scanner.Rules))
	p.scanner = scanner

	// 2. æ‰«æç›®æ ‡ç›®å½• (åº”æ€¥å“åº”ä¼˜åŒ–: åªæ‰«ææ”»å‡»è€…å¸¸ç”¨è½åœ°ç‚¹)
	var targetDirs []string
	if runtime.GOOS == "windows" {
		// Windows: èšç„¦æ”»å‡»è½åœ°ç‚¹ï¼Œè€Œéå…¨ç›˜æ‰«æ
		targetDirs = []string{
			"C:\\Windows\\Temp", // æœ€é«˜ä¼˜å…ˆçº§ (90%çš„æ”»å‡»)
			"C:\\Users\\Public", // é«˜ä¼˜å…ˆçº§ (å‹’ç´¢è½¯ä»¶/æ¨ªå‘ç§»åŠ¨)
			"C:\\Temp",          // æœåŠ¡å™¨å¸¸è§
		}
		// æ³¨: C:\ProgramData å·²ç§»é™¤ (å¤ªå¤§ï¼ŒçœŸå®æ”»å‡»å°‘ï¼Œè¢« PersistencePlugin è¦†ç›–)
	} else {
		// Linux: ä¸´æ—¶ç›®å½•å’Œå¸¸è§WebShellè·¯å¾„
		targetDirs = []string{
			"/tmp",
			"/var/tmp",
			"/dev/shm", // å†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼Œæ— æ–‡ä»¶è½åœ°æ”»å‡»å¸¸ç”¨
		}
	}

	// éœ€è¦è·³è¿‡çš„ç›®å½•
	skipDirs := map[string]bool{
		"node_modules":        true,
		".git":                true,
		".vscode":             true,
		"AppData":             true,
		"Windows":             true,
		"Program Files":       true,
		"Program Files (x86)": true,
		"GamePP":              true,
		"Epic":                true,
		"Steam":               true,
		"Microsoft":           true,
		"Package Cache":       true,
		"Packages":            true,
		"Kaspersky":           true,
	}

	// å¹¶å‘æ‰«æé…ç½®
	numWorkers := runtime.NumCPU()
	fileChan := make(chan string, 100)

	fileCount := 0
	maxFiles := 5000

	// å¯åŠ¨å·¥ä½œåç¨‹æ± 
	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for path := range fileChan {
				if res := p.scanFile(path); res != nil {
					resultsMutex.Lock()
					results = append(results, *res)
					resultsMutex.Unlock()
				}
			}
		}()
	}

	// éå†ç›®å½•ï¼Œå°†æ–‡ä»¶å‘é€åˆ° channel
	for _, root := range targetDirs {
		if _, err := os.Stat(root); os.IsNotExist(err) {
			continue
		}

		filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return nil
			}

			// è¾¾åˆ°æ–‡ä»¶æ•°ä¸Šé™
			if fileCount >= maxFiles {
				return filepath.SkipAll
			}

			// è·³è¿‡å¤§ç›®å½•
			if d.IsDir() {
				for skip := range skipDirs {
					if strings.Contains(d.Name(), skip) {
						return filepath.SkipDir
					}
				}
				return nil
			}

			// æ™ºèƒ½æ–‡ä»¶ç±»å‹è¿‡æ»¤ (æ€§èƒ½ + å®‰å…¨å¹³è¡¡)
			ext := strings.ToLower(filepath.Ext(path))

			// æ ¸å¿ƒå¯æ‰§è¡Œæ–‡ä»¶ - æ‰€æœ‰ç›®å½•éƒ½æ£€æŸ¥
			coreExecs := map[string]bool{
				".exe": true, ".dll": true, ".sys": true,
			}

			// é«˜å±è„šæœ¬ - åªåœ¨ Temp ç›®å½•æ£€æŸ¥ (æ”»å‡»è€…å¸¸ç”¨è½åœ°ç‚¹)
			scripts := map[string]bool{
				".ps1": true, ".bat": true, ".cmd": true,
				".vbs": true, ".js": true, ".hta": true,
			}

			// åˆ¤æ–­æ˜¯å¦åœ¨ Temp ç›®å½•
			inTempDir := strings.Contains(strings.ToLower(path), "temp") ||
				strings.Contains(strings.ToLower(path), "tmp")

			// è¿‡æ»¤é€»è¾‘
			if ext != "" {
				if !coreExecs[ext] && !(inTempDir && scripts[ext]) {
					return nil // è·³è¿‡
				}
			} else {
				// æ— æ‰©å±•åæ–‡ä»¶: åªåœ¨ Temp æ£€æŸ¥ä¸” <5MB
				if !inTempDir {
					return nil
				}
				info, err := d.Info()
				if err != nil || info.Size() > 5*1024*1024 {
					return nil
				}
			}

			// å‘é€æ–‡ä»¶åˆ° channel è¿›è¡Œå¹¶å‘æ‰«æ
			fileCount++
			if fileCount%100 == 0 {
				fmt.Printf("  ğŸ” å·²æ‰«æ %d/%d ä¸ªæ–‡ä»¶...\r", fileCount, maxFiles)
			}

			fileChan <- path
			return nil
		})
	}

	// å…³é—­ channel å¹¶ç­‰å¾…æ‰€æœ‰å·¥ä½œåç¨‹å®Œæˆ
	close(fileChan)
	wg.Wait()

	fmt.Printf("\n  âœ“ å…±æ‰«æ %d ä¸ªæ–‡ä»¶ (ä½¿ç”¨ %d ä¸ªå¹¶å‘çº¿ç¨‹)\n", fileCount, numWorkers)

	// å¦‚æœæ²¡æœ‰å‘ç°ä»»ä½•å¨èƒï¼Œè¿”å› pass çŠ¶æ€
	if len(results) == 0 {
		results = append(results, core.Result{
			Plugin:      p.Name(),
			Level:       "pass",
			Description: "æ¶æ„è½¯ä»¶æ‰«æå®Œæˆï¼Œæœªå‘ç°å¨èƒ",
			Reference:   fmt.Sprintf("å·²æ‰«æç›®å½•: %v", targetDirs),
		})
	}

	return results, nil
}

func (p *MalwareScanPlugin) scanFile(path string) *core.Result {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil
	}
	// é™åˆ¶æ–‡ä»¶å¤§å°ä¸º 50MBï¼ˆæ¶æ„è½¯ä»¶é€šå¸¸è¾ƒå°ï¼‰
	if len(data) > 50*1024*1024 {
		return nil
	}

	// ä½¿ç”¨ YARA-Lite å¼•æ“æ‰«æ
	if p.scanner != nil && len(p.scanner.Rules) > 0 {
		matches := p.scanner.Scan(data)
		if len(matches) > 0 {
			return &core.Result{
				Plugin:      p.Name(),
				Level:       "critical",
				Description: fmt.Sprintf("æ£€æµ‹åˆ°æ¶æ„è½¯ä»¶/é»‘å®¢å·¥å…·: %s", strings.Join(matches, ", ")),
				Reference:   path,
				Advice:      "ç«‹å³éš”ç¦»è¯¥æ–‡ä»¶å¹¶è¿›è¡Œæ·±åº¦åˆ†æï¼Œå¯èƒ½æ˜¯æœ¨é©¬ã€åé—¨ã€é»‘å®¢å·¥å…·æˆ–æ¸—é€æ¡†æ¶ã€‚",
			}
		}
	}

	return nil
}
